use std::net::SocketAddr;

use anyhow::{bail, Result};
use tracing::{debug, info};

use tokio::{
    io::{AsyncBufReadExt, AsyncWriteExt},
    net::{TcpListener, TcpStream},
    select,
};

pub async fn accept_encrypt_tcp(port: i32, server: SocketAddr) -> Result<()> {
    let address = format!("0.0.0.0:{}", port);
    let listener = TcpListener::bind(address.clone()).await?;
    info!("本地加密协议端口{}启动成功!!!", &address);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!("Accepting EncryptData Tcp connection from {}", addr);
        tokio::spawn(async move { transfer(stream, server).await });
    }
}

async fn transfer(stream: TcpStream, addr: SocketAddr) -> Result<()> {
    let (worker_r, mut worker_w) = tokio::io::split(stream);
    let worker_r = tokio::io::BufReader::new(worker_r);
    let mut worker_r = worker_r.lines();

    info!("开始读取链接");
    let first_pacakge = match worker_r.next_line().await {
        Ok(res) => match res {
            Some(buf) => buf,
            None => {
                bail!("矿机下线")
            }
        },
        Err(e) => return bail!("读取矿机输入超时 {}", e),
    };

    dbg!(first_pacakge);

    loop {
        select! {
            res = worker_r.next_line() => {
                let buffer = match res {
                    Ok(res) => match res {
                        Some(buf) => buf,
                        None => bail!("矿机下线了")
                    },
                    Err(e) => bail!("读取超时了 矿机下线了: {}",e),
                };

                #[cfg(debug_assertions)]
                debug!("------> :  矿机 -> 矿池  {:?}", buffer);
                let buffer: Vec<_> = buffer.split("\n").collect();
                for buf in buffer {
                    if buf.is_empty() {
                        continue;
                    }
                }
            }
        }
    }
}
